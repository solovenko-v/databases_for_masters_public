# ТЕМА ЛЕКЦИИ: Поиск по шаблону
# ЦЕЛИ ЛЕКЦИИ: 
* обеспечить усвоение основных принципов поиска по шаблону и построения регулярных выражений
# КОМПЕТЕНЦИИ ЛЕКЦИИ:
* ПК-2: Способностью разрабатывать и анализировать концептуальные и теоретические модели решаемых научных проблем и задач

# МАТЕРИАЛ ЛЕКЦИИ
PostgreSQL предлагает три разных способа поиска текста по шаблону: традиционный оператор LIKE языка SQL, более современный SIMILAR TO и регулярные выражения в стиле POSIX. Помимо простых операторов, отвечающих на вопрос «соответствует ли строка этому шаблону?», в PostgreSQL есть функции для извлечения или замены соответствующих подстрок и для разделения строки по заданному шаблону.

## LIKE
Если это возможно, то рекомендуется использовать именно этот вариант поиска по шаблону, как самый быстрый и прозрачный.
```
строка LIKE шаблон [ESCAPE спецсимвол]  
строка NOT LIKE шаблон [ESCAPE спецсимвол]
```

Выражение LIKE возвращает true, если строка соответствует заданному шаблону. (Как можно было ожидать, выражение NOT LIKE возвращает false, когда LIKE возвращает true, и наоборот. Этому выражению равносильно выражение NOT (`строка LIKE шаблон`).)

Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет в точности строку и LIKE работает как оператор сравнения. Подчёркивание (_) в шаблоне подменяет (вместо него подходит) любой символ; а знак процента (%) подменяет любую (в том числе и пустую) последовательность символов.

Несколько примеров:
* `'abc' LIKE 'abc'`    *true*
* `'abc' LIKE 'a%'`     *true*
* `'abc' LIKE '_b_'`  *true*
* `'abc' LIKE 'c'`      *false*

При проверке по шаблону LIKE всегда рассматривается вся строка. Поэтому, если нужно найти последовательность символов где-то в середине строки, шаблон должен начинаться и заканчиваться знаками процента.

Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, перед соответствующим символом в шаблоне нужно добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная косая черта, но с помощью предложения ESCAPE можно выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте его.

Также можно отказаться от спецсимвола, написав ESCAPE ''. При этом механизм спецпоследовательностей фактически отключается и использовать знаки процента и подчёркивания буквально в шаблоне нельзя.

Вместо LIKE можно использовать ключевое слово ILIKE, чтобы поиск был регистр-независимым с учётом текущей языковой среды. Этот оператор не описан в стандарте SQL; это расширение PostgreSQL.

#### Альтернативное написание ключевых слов сопоставления по шаблону:
| Выражение | Синоним |
|:---------:|:-------:|
| `LIKE` | ~~ |
| `ILIKE` | ~~* |
| `NOT LIKE` | !~~ |
| `NOT ILIKE` | !~~* |


## SIMILAR TO
Выражение SIMILAR TO является чем-то средним между LIKE и выражениями POSIX. Если хотите, можете почитать про них самостоятельно (например в [1]).

## POSIX
Регулярные выражения POSIX предоставляют более мощные средства поиска по шаблонам, чем операторы LIKE и SIMILAR TO.  
#### Операторы регулярных выражений 
|Оператор|Описание|
|:-:|:-|
|~|Проверяет соответствие регулярному выражению с учётом регистра|
|~*|Проверяет соответствие регулярному выражению без учёта регистра|
|!~|Проверяет несоответствие регулярному выражению с учётом регистра|
|!~*|Проверяет несоответствие регулярному выражению без учёта регистра|

Регулярное выражение — это последовательность символов, представляющая собой краткое определение набора строк (регулярное множество). Строка считается соответствующей регулярному выражению, если она является членом регулярного множества, описываемого регулярным выражением. Как и для LIKE, символы шаблона непосредственно соответствуют символам строки, за исключением специальных символов языка регулярных выражений. При этом спецсимволы регулярных выражений отличается от спецсимволов LIKE. В отличие от шаблонов LIKE, регулярное выражение может совпадать с любой частью строки, если только оно не привязано явно к началу и/или концу строки.  
#### Несколько примеров:
|Выражение|Результат|
|:-:|:-:|
|`'abc' ~ 'abc'`|    `true`|
|`'abc' ~ '^a'`|    `true`|
|`'abc' ~ '(b|d)'`|  `true`|
|`'abc' ~ '^(b|c)'`| `false`|

Кроме проверки соответствия шаблону в PostgreSQL есть ряд полезных функций, использующих регулярные выражения.
#### Функции с регулярными выражениями:
|Функция|Тип|Описание|Пример|Результат|
|-------|---|--------|------|---------|
|**substring**(*string* TEXT FROM *pattern* TEXT)|TEXT|Извлекает подстроку, соответствующую регулярному выражению в стиле POSIX.|substring('Thomas' from '...$')|mas|
|**regexp\_replace**​(*string* TEXT, *pattern* TEXT, *replacement* TEXT [, flags text])|TEXT|Заменяет подстроки, соответствующие заданному регулярному выражению в стиле POSIX.|regexp\_replace('foobarbaz', 'b..', 'X')|fooXbaz|
|**regexp\_matches**​(*string* TEXT, *pattern* TEXT [, *flags* TEXT])|SETOF TEXT[]|Возвращает все подходящие подстроки, полученные в результате применения регулярного выражения в стиле POSIX к string.|regexp\_matches​('foobar​bequebaz', '(bar)(beque)')|{bar,beque}|
|**regexp\_split\_to\_table**(*string* TEXT, *pattern* TEXT [, *flags* TEXT])|SETOF TEXT|Разделяет содержимое string на элементы, используя в качестве разделителя регулярное выражение POSIX.|regexp\_split\_to\_table('polynomial interpolation', E'\\s+')|polynomial interpolation (2 строки)|
|**regexp\_split\_to\_array**(*string* TEXT, *pattern* TEXT [, *flags* TEXT])|TEXT[]|Разделяет содержимое string на элементы, используя в качестве разделителя регулярное выражение POSIX.|regexp\_split\_to\_array('hello world', E'\\s+')|{hello,world}|

### Подробное описание регулярных выражений
Регулярное выражение определяется как одна или более ветвей, разделённых символами |. Оно считается соответствующим всему, что соответствует одной из этих ветвей.

**Ветвь** — это ноль или несколько количественных атомов или ограничений, соединённых вместе. Соответствие ветви в целом образуется из соответствия первой части, за которым следует соответствие второй части и т. д.; пустой ветви соответствует пустая строка.

**Количественный атом** — это атом, за которым может следовать определитель количества (**квантификатор**). Без этого определителя ему соответствует одно вхождение атома. С определителем количества ему может соответствовать некоторое число вхождений этого атома.

#### Атомы регулярных выражений:
|Атом|Описание|
|-|-|
|(re)|(где re — любое регулярное выражение) описывает соответствие re, при этом данное соответствие захватывается для последующей обработки|
|(?:re)|подобно предыдущему, но соответствие не захватывается (т. е. это набор скобок «без захвата») (применимо только к ARE)|
|.|соответствует любому символу|
|[символы]|	выражение в квадратных скобках, соответствует любому из символов|
|\k|(где k — не алфавитно-цифровой символ) соответствует обычному символу буквально, т. е. \\ соответствует обратной косой черте|
|\c|	где c — алфавитно-цифровой символ (за которым могут следовать другие символы), это спецсимвол|
|{|	когда за этим символом следует любой символ, кроме цифры, этот атом соответствует левой фигурной скобке ({), если же за ним следует цифра, это обозначает начало границы|
|x|	(где x — один символ, не имеющий специального значения) соответствует этому символу|

Выражение RE не может заканчиваться обратной косой чертой (\\).

#### Определители количества в регулярных выражениях (Квантификаторы):
|Определитель|Соответствует|
|------------|-------------|
|*|	0 или более вхождений атома|
|+|	1 или более вхождений атома|
|?|	0 или 1 вхождение атома|
|{m}|	ровно m вхождений атома|
|{m,}|	m или более вхождений атома|
|{m,n}|	от m до n (включая границы) вхождений атома; m не может быть больше n|
|*?|	не жадная версия *|
|+?|	не жадная версия +|
|??|	не жадная версия ?|
|{m}?|	не жадная версия {m}|
|{m,}?|	не жадная версия {m,}|
|{m,n}?|	не жадная версия {m,n}|

В формах с {...} числа m и n определяют так называемые границы количества. Эти числа должны быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 включительно.

Не жадные определители (допустимые только в ARE) описывают те же возможные соответствия, что и аналогичные им обычные («жадные»), но предпочитают выбирать наименьшее, а не наибольшее количество вхождений.

**Ограничению** соответствует пустая строка, но это соответствие возможно только при выполнении определённых условий. Ограничения могут использоваться там же, где и атомы, за исключением того, что их нельзя дополнять определителями количества.

#### Ограничения в регулярных выражениях:
|Ограничение|Описание|
|-----------|--------|
|^|	соответствует началу строки|
|$|	соответствует концу строки|
|(?=re)|	позитивный просмотр вперёд находит соответствие там, где начинается подстрока, соответствующая re (только для ARE)|
|(?!re)|	негативный просмотр вперёд находит соответствие там, где не начинается подстрока, соответствующая re (только для ARE)|
|(?<=re)|	позитивный просмотр назад находит соответствие там, где заканчивается подстрока, соответствующая re (только для ARE)|
|(?<\!re)|	негативный просмотр назад находит соответствие там, где не заканчивается подстрока, соответствующая re (только для ARE)|

### Выражения в квадратных скобках

Выражение в квадратных скобках содержит список символов, заключённый в []. Обычно ему соответствует любой символ из списка (об исключении написано ниже). Если список начинается с ^, ему соответствует любой символ, который не перечисляется далее в этом списке. Если два символа в списке разделяются знаком -, это воспринимается как краткая запись полного интервала символов между двумя заданными (и включая их) в порядке сортировки; например выражению [0-9] в ASCII соответствует любая десятичная цифра. Два интервала не могут разделять одну границу, т. е. выражение a-c-e недопустимо. Интервалы зависят от порядка сортировки, который может меняться, поэтому в переносимых программах их лучше не использовать.

Чтобы включить в список ], этот символ нужно написать первым (сразу за ^, если он присутствует). Чтобы включить в список символ -, его нужно написать первым или последним, либо как вторую границу интервала. Указать - в качестве первой границы интервал можно, заключив его между [. и .], чтобы он стал элементом сортировки (см. ниже). За исключением этих символов, некоторых комбинаций с [ (см. следующие абзацы) и спецсимволов (в ARE), все остальные специальные символы в квадратных скобках теряют своё особое значение. В частности, символ \ по правилам ERE или BRE воспринимается как обычный, хотя в ARE он экранирует символ, следующий за ним.

Выражения в квадратных скобках могут содержать элемент сортировки (символ или последовательность символов или имя такой последовательности), определение которого заключается между [. и .]. Определяющая его последовательность воспринимается в выражении в скобках как один элемент. Это позволяет включать в такие выражения элементы, соответствующие последовательности нескольких символов. Например, с элементом сортировки ch в квадратных скобках регулярному выражению [[.ch.]]*c будут соответствовать первые пять символов строки chchcc.

В квадратных скобках могут содержаться элементы сортировки, заключённые между [= и =], обозначающие классы эквивалентности, т. е. последовательности символов из всех элементов сортировки, эквивалентных указанному, включая его самого. (Если для этого символа нет эквивалентных, он обрабатывается, как заключённый между [. и .].) Например, если е и ё — члены одного класса эквивалентности, выражения [[=е=]], [[=ё=]] и [её] будут равнозначными. Класс эквивалентности нельзя указать в качестве границы интервала.

В квадратных скобках может также содержаться имя класса символов, заключённое между [: и :], и заменяющее список всех символов этого класса. Стандартные имена классов: alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper и xdigit. Весь этот набор классов определён в ctype и он может меняться в зависимости от локали (языковой среды). Класс символов также нельзя использовать в качестве границы интервала.

Есть два особых вида выражений в квадратных скобках: выражения [[:<:]] и [[:>:]], представляющие собой ограничения, соответствующие пустым строкам в начале и конце слова. Слово в данном контексте определяется как последовательность словосоставляющих символов, перед или после которой нет словосоставляющих символов. Словосоставляющий символ — это символ класса alnum (определённого в ctype) или подчёркивание. Это расширение совместимо со стандартом POSIX 1003.2, но не описано в нём, и поэтому его следует использовать с осторожностью там, где важна совместимость с другими системами. Обычно лучше использовать ограничивающие спецсимволы, описанные ниже; они также не совсем стандартны, но набрать их легче.

### Спецсимволы регулярных выражений

**Спецсимволы** — это специальные команды, состоящие из \ и последующего алфавитно-цифрового символа. Можно выделить следующие категории спецсимволов: обозначения символов, коды классов, ограничения и ссылки назад. Символ \, за которым идёт алфавитно-цифровой символ, не образующий допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет: вне квадратных скобок пара из \ и последующего алфавитно-цифрового символа, воспринимается просто как данный символ, а в квадратных скобках и сам символ \ воспринимается просто как обратная косая черта. (Последнее на самом деле нарушает совместимость между ERE и ARE.)

#### Спецобозначения символов в регулярных выражениях:
|Спецсимвол|Описание|
|----------|--------|
|\a|	символ звонка, как в C|
|\b|	символ «забой», как в C|
|\B|	синоним для обратной косой черты (\), сокращающий потребность в дублировании этого символа|
|\cX|	(где X — любой символ) символ, младшие 5 бит которого те же, что и у X, а остальные равны 0|
|\e|	символ, определённый в последовательности сортировки с именем ESC, либо, если таковой не определён, символ с восьмеричным значением 033|
|\f|	подача формы, как в C|
|\n|	новая строка, как в C|
|\r|	возврат каретки, как в C|
|\t|	горизонтальная табуляция, как в C|
|\uwxyz|	(где wxyz ровно четыре шестнадцатеричные цифры) символ с шестнадцатеричным кодом 0xwxyz|
|\Ustuvwxyz|	(где stuvwxyz ровно восемь шестнадцатеричных цифр) символ с шестнадцатеричным кодом 0xstuvwxyz|
|\v|	вертикальная табуляция, как в C|
|\xhhh|	(где hhh — несколько шестнадцатеричных цифр) символ с шестнадцатеричным кодом 0xhhh (символ всегда один вне зависимости от числа шестнадцатеричных цифр)|
|\0|	символ с кодом 0 (нулевой байт)|
|\xy|	(где xy — ровно две восьмеричных цифры, не ссылка назад) символ с восьмеричным кодом 0xy|
|\xyz|	(где xyz — ровно три восьмеричных цифры, не ссылка назад) символ с восьмеричным кодом 0xyz|

Шестнадцатеричные цифры записываются символами 0-9 и a-f или A-F. Восьмеричные цифры — цифры от 0 до 7.

Спецпоследовательности с числовыми кодами, задающими значения вне диапазона ASCII (0-127), воспринимаются по-разному в зависимости от кодировки базы данных. Когда база данных имеет кодировку UTF-8, спецкод равнозначен позиции символа в Unicode, например, \u1234 обозначает символ U+1234. Для других многобайтных кодировок спецпоследовательности обычно просто задают серию байт, определяющих символ. Если в кодировке базы данных отсутствует символ, заданный спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей соответствовать.

Символы, переданные спецобозначением, всегда воспринимаются как обычные символы. Например, \135 кодирует ] в ASCII, но спецпоследовательность \135 не будет закрывать выражение в квадратных скобках.

#### Спецкоды классов в регулярных выражениях
|Спецсимвол|Описание|
|----------|--------|
|\d|	[[:digit:]]|
|\s|	[[:space:]]|
|\w|	[[:alnum:]_] (подчёркивание также включается)|
|\D|	[^[:digit:]]|
|\S|	[^[:space:]]|
|\W|	[^[:alnum:]_] (подчёркивание также включается)|

В выражениях в квадратных скобках спецсимволы \d, \s и \w теряют свои внешние квадратные скобки, а \D, \S и \W — недопустимы. (Так что, например запись [a-c\d] равнозначна [a-c[:digit:]]. А запись [a-c\D], которая была бы равнозначна [a-c^[:digit:]], — недопустима.)

#### Спецсимволы ограничений в регулярных выражений
|Спецсимвол|Описание|
|----------|--------|
|\A|	соответствует только началу строки|
|\m|	соответствует только началу слова|
|\M|	соответствует только концу слова|
|\y|	соответствует только началу или концу слова|
|\Y|	соответствует только положению не в начале и не в конце слова|
|\Z|	соответствует только концу строки|

Определением слова здесь служит то же, что было приведено выше в описании [[:<:]] и [[:>:]]. В квадратных скобках спецсимволы ограничений не допускаются.

#### Ссылки назад в регулярных выражениях
|Спецсимвол|Описание|
|----------|--------|
|\m|	(где m — цифра, отличная от 0) — ссылка назад на подвыражение под номером m|
|\mnn|	(где m — цифра, отличная от 0, а nn — ещё несколько цифр с десятичным значением mnn, не превышающим число закрытых до этого скобок с захватом) ссылка назад на подвыражение под номером mnn|

### Метасинтаксис регулярных выражений
В дополнение к основному синтаксису, описанному выше, можно использовать также несколько особых форм и разнообразные синтаксические удобства.

Регулярное выражение может начинаться с одного из двух специальных префиксов режима. Если RE начинается с \*\*\*:, его продолжение рассматривается как ARE. (В PostgreSQL это обычно не имеет значения, так как регулярные выражения воспринимаются как ARE по умолчанию; но это может быть полезно, когда параметр флаги функций regex включает режим ERE или BRE.) Если RE начинается с ***=, его продолжение воспринимается как обычная текстовая строка, все его символы воспринимаются буквально.

ARE может начинаться со встроенных параметров: последовательности (?xyz) (где xyz — один или несколько алфавитно-цифровых символов), определяющих параметры остального регулярного выражения. Эти параметры переопределяют любые ранее определённые параметры, в частности они могут переопределить режим чувствительности к регистру, подразумеваемый для оператора regex, или параметр флаги функции regex.

#### Буквы встроенных параметров ARE
|Параметр|Описание|
|--------|--------|
|b|	продолжение регулярного выражения — BRE|
|c|	поиск соответствий с учётом регистра (переопределяет тип оператора)
|e|	продолжение RE — ERE|
|i|	поиск соответствий без учёта регистра (переопределяет тип оператора)|
|m|	исторически сложившийся синоним n|
|n|	поиск соответствий с учётом перевода строк|
|p|	переводы строк учитываются частично|
|q|	продолжение регулярного выражения — обычная строка («в кавычках»), содержимое которой воспринимается буквально|
|s|	поиск соответствий без учёта перевода строк (по умолчанию)|
|t|	компактный синтаксис (по умолчанию)|
|w|	переводы строк учитываются частично, но в другом, «странном» режиме|
|x|	развёрнутый синтаксис|

Внедрённые параметры начинают действовать сразу после скобки ), завершающей их последовательность. Они могут находиться только в начале ARE (после указания \*\*\*:, если оно присутствует).

Помимо обычного (компактного) синтаксиса RE, в котором имеют значение все символы, поддерживается также развёрнутый синтаксис, включить который можно с помощью встроенного параметра x. В развёрнутом синтаксисе игнорируются пробельные символы, а также все символы от # до конца строки (или конца RE). Это позволяет разделять RE на строки и добавлять в него комментарии. Но есть три исключения:

пробельный символ или #, за которым следует \, сохраняется

пробельный символ или # внутри выражения в квадратных скобках сохраняется

пробельные символы и комментарии не могут присутствовать в составных символах, например, в (?:

В данном контексте пробельными символами считаются пробел, табуляция, перевод строки и любой другой символ, относящийся к классу символов space.

И наконец, в ARE последовательность (?#ttt) (где ttt — любой текст, не содержащий )) вне квадратных скобок также считается комментарием и полностью игнорируется. При этом она так же не может находиться внутри составных символов, таких как (?:. Эти комментарии в большей степени историческое наследие, чем полезное средство; они считаются устаревшими, а вместо них рекомендуется использовать развёрнутый синтаксис.

Ни одно из этих расширений метасинтаксиса не будет работать, если выражение начинается с префикса ***=, после которого строка воспринимается буквально, а не как RE.


### Правила соответствия регулярным выражениям

В случае, когда RE может соответствовать более чем одной подстроке в заданной строке, соответствующей RE считается подстрока, которая начинается в ней первой. Если к данной позиции подобных соответствующих подстрок оказывается несколько, из них выбирается либо самая длинная, либо самая короткая из возможных, в зависимости от того, какой режим выбран в RE: жадный или не жадный.

Где жадный или не жадный характер RE определяется по следующим правилам:

Большинство атомов и все ограничения не имеют признака жадности (так как они всё равно не могут соответствовать подстрокам разного состава).

Скобки, окружающие RE, не влияют на его «жадность».

Атом с определителем фиксированного количества ({m} или {m}?) имеет ту же характеристику жадности (или может не иметь её), как и сам атом.

Атом с другими обычными определителями количества (включая {m,n}, где m равняется n) считается жадным (предпочитает соответствие максимальной длины).

Атом с не жадным определителем количества (включая {m,n}?, где m равно n) считается не жадным (предпочитает соответствие минимальной длины).

Ветвь (RE без оператора | на верхнем уровне) имеет ту же характеристику жадности, что и первый количественный атом в нём, имеющий атрибут жадности.

RE, образованное из двух или более ветвей, соединённых оператором |, всегда считается жадным.

Эти правила связывают характеристики жадности не только с отдельными количественными атомами, но и с ветвями и целыми RE, содержащими количественные атомы. Это означает, что при сопоставлении ветвь или целое RE может соответствовать максимально длинной или короткой подстроке в целом. Когда определена длина всего соответствия, часть его, соответствующая конкретному подвыражению, определяется с учётом характеристики жадности для этого подвыражения, при этом подвыражения, начинающиеся в RE раньше, имеют больший приоритет, чем следующие за ними.

Это иллюстрирует следующий пример:

```
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
Результат: 123
```

```
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
Результат: 1
```

В первом случае, RE в целом жадное, так как жадным является атом Y*. Соответствие ему начинается с буквы Y и оно включает подстроку максимальной длины с этого места, т. е. подстроку Y123. Результат выражения — её часть, соответствующая подвыражению в скобках, т. е. 123. Во втором случае, RE в целом наследует не жадный характер от атома Y*?. Соответствие ему так же начинается с Y, но включает оно подстроку минимальной длины с этого места, т. е. Y1. И хотя подвыражение [0-9]{1,3} имеет жадный характер, оно не может повлиять на выбор длины соответствия в целом, поэтому ему остаётся только подстрока 1.

Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё соответствие будет максимально длинным или коротким в зависимости от характеристики всего RE. Характеристики, связанные с подвыражениями, влияют только на то, какую часть подстроки может «поглотить» одно подвыражение относительно другого.

Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению или всему RE, можно использовать определители {1,1} и {1,1}?, соответственно. Это полезно, когда вам нужно, чтобы общая характеристика жадности RE отличалась от той, что вытекает из его элементов. Например, предположим, что вы пытаетесь выделить из строки, содержащей несколько цифр, эти цифры и части до и после них. Можно попытаться сделать это так:

```
SELECT regexp_matches('abc01234xyz', '(.*)(\d+)(.*)');
Результат: {abc0123,4,xyz}
```
Но это не будет работать: первая группа .* — «жадная», она «съест» всё, что сможет, оставляя для соответствия \d+ только последнюю возможность, то есть последнюю цифру. Можно попытаться сделать запрос «нежадным»:

```
SELECT regexp_matches('abc01234xyz', '(.*?)(\d+)(.*)');
Результат: {abc,0,""}
```
И это не будет работать, так теперь весь RE в целом стал нежадным, и все соответствия завершаются как можно раньше. Но мы можем получить нужный результат, явно сделав жадным всё RE:

```
SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
Результат: {abc,01234,xyz}
```
Управление общей характеристикой «жадности» RE независимо от «жадности» его компонентов даёт большую гибкость в описании шаблонов переменной длины.

При определении более длинного или более короткого соответствия длины соответствий определяются в символах, а не в элементах сортировки. Пустая строка считается длиннее, чем отсутствие соответствия. Например, выражению bb* соответствуют три символа в середине строки abbbc, выражению (week|wee)(night|knights) — все десять символов weeknights; когда выражение (.*).* сопоставляется со строкой abc, подвыражению в скобках соответствуют все три символа; а когда (a*)* сопоставляется со строкой bc, то и RE в целом, и подстроке в скобках соответствует пустая строка.

Игнорирование регистра символов даёт практически тот же эффект, как если бы в алфавите исчезли различия прописных и строчных букв. Если буква, существующая и в верхнем, и в нижнем регистре, фигурирует вне квадратных скобок как обычный символ, она по сути преобразуется в выражение в квадратных скобках, содержащее оба варианта, например x становится [xX]. Если же она фигурирует в выражении в квадратных скобках, в это выражение добавляются все её варианты, например [x] становится [xX], а [^x] — [^xX].

Когда включён режим учёта перевода строк, атом . и выражения в квадратных скобках с ^ никогда не будут соответствовать символам конца строки (так что соответствия никогда не будут пересекать границы строк, если в RE нет явных указаний на эти символы), а ^ и $ будут соответствовать пустой подстроке не только в начале и конце всего текста, но и в начале и конце каждой отдельной его строки. Однако спецсимволы ARE \A и \Z по-прежнему будут соответствовать только началу и концу всего текста.

В режиме, когда переводы строк учитываются частично, особый смысл перевод строк имеет для атома . и выражений в квадратных скобках, но не для ^ и $.

В обратном частичном режиме, перевод строк имеет особый смысл для ^ и $, как и в режиме с учётом перевода строк, но не для . и выражений в квадратных скобках. Данный режим не очень полезен, но существует для симметрии.

# Литература
1. [https://postgrespro.ru/docs/postgresql/9.6/functions-matching.html#posix-escape-sequences](https://postgrespro.ru/docs/postgresql/9.6/functions-matching.html#posix-escape-sequences)
1. [https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F#Символьные_классы_(наборы_символов)](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F#Символьные_классы_(наборы_символов))